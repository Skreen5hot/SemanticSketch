<div class="sections">
 <h1>SPARQL Query App</h1>

    <!-- Updated file selection and management area -->
    <section class="file-section" data-section="1">
        <h3>RDF Input (Turtle and N-Triples):</h3>
        <select class="file-select">
            <option value="" disabled selected>Select a file to open</option>
        </select>
        <button class="fileOpenBtn">Open</button>
        <button class="fileSaveBtn">Save</button>
        <button class="fileSaveAsBtn">Save As</button>
        <br>
        <textarea id="rdfInput" rows="10" cols="100"></textarea>
        <br><br>
    </section>

    <h2>SPARQL Query</h2>
    <textarea id="queryInput" placeholder="Enter your SPARQL query here..." rows="10" cols="100">PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT *
WHERE {
    ?s ?p ?o .
}LIMIT 5</textarea>
    <button onclick="executeQuery()">Execute Query</button>

    <h2>Results</h2>
    <div id="results"></div>
</div>
    <script>
        let store = new N3.Store();
        const DEBUG = false;

        function log(message) {
            if (DEBUG) {
                console.log(message);
            }
            document.getElementById('results').innerHTML += message + '<br>';
        }

        async function loadRDFContent(content, format = 'Turtle') {
            // Parse RDF content using the N3 library and populate the store
            const parser = new N3.Parser({ format: format });
            parser.parse(content, (error, quad, prefixes) => {
                if (error) {
                    log('Error parsing RDF content: ' + error);
                } else if (quad) {
                    store.addQuad(quad);
                } else {
                    log('File loaded successfully. Triples count: ' + store.size);
                }
            });
        }

        // Existing function to load file content from IndexedDB
        async function loadFileFromIndexDB(fileName) {
            const content = await loadFileFromList(fileName);
            if (content) {
                // Load content into textarea and parse RDF
                document.getElementById('rdfInput').value = content;
                loadRDFContent(content);
            } else {
                log('Failed to load file from IndexedDB.');
            }
        }

        async function executeQuery() {
            const queryEngine = new Comunica.QueryEngine();
            let query = document.getElementById('queryInput').value.trim();

            query = query.replace(/\ba\s/g, 'rdf:type ');  // Replace 'a' with 'rdf:type'
            query = query.replace(/(\bhttp:\/\/[^\s<>]+)(?=\s)/g, '<$1>');  // Add angle brackets around IRIs
            query = query.replace(/\b(\w+:\w+)\b(?!>)/g, '<$1>');  // Wrap unbracketed CURIEs with angle brackets

            log('Starting query execution...');
            log('Query: ' + query);
            log('Store size: ' + store.size);

            try {
                const result = await queryEngine.query(query, { sources: [store] });
                
                if (result.resultType === 'bindings') {
                    const bindingsStream = await result.execute();
                    
                    let tableHTML = '<table border="1"><thead><tr>';
                    let headers = [];
                    let count = 0;

                    bindingsStream.on('data', (binding) => {
                        count++;
                        if (count === 1) {
                            for (const [key] of binding.entries) {
                                headers.push(key);
                                tableHTML += `<th>${key}</th>`;
                            }
                            tableHTML += '</tr></thead><tbody>';
                        }

                        tableHTML += '<tr>';
                        for (const [key, value] of binding.entries) {
                            tableHTML += `<td>${value.value}</td>`;
                        }
                        tableHTML += '</tr>';
                    });

                    bindingsStream.on('end', () => {
                        tableHTML += '</tbody></table>';
                        log(`Processed ${count} bindings.`);
                        document.getElementById('results').innerHTML = tableHTML;
                        log('Query execution completed.');
                    });

                    bindingsStream.on('error', (error) => {
                        log('Error processing bindings: ' + error);
                    });
                } else {
                    log('Unsupported result type.');
                }
            } catch (error) {
                log('Error executing query: ' + error);
                document.getElementById('results').textContent = 'Error: ' + error.message;
            }
        }

        // Event listener for file buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('fileOpenBtn')) {
                const section = e.target.closest('.file-section');
                const select = section.querySelector('.file-select');
                if (select.value) {
                    loadFileFromIndexDB(select.value);
                } else {
                    alert('Please select a file to open.');
                }
            }
        });
    </script>
